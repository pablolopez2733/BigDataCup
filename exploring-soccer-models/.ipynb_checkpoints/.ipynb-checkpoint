{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd \n",
    "\n",
    "# data for testing\n",
    "actions = pd.read_csv('actions.csv')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Load modules\n",
    "\n",
    "#don't worry about these two, but for now, download socceraction module so you can run this.\n",
    "import socceraction.spadl.config as spadlconfig \n",
    "from socceraction.spadl.base import SPADLSchema \n",
    "\n",
    "from typing import Callable, List, Tuple\n",
    "import numpy as np  # type: ignore\n",
    "from pandera.typing import DataFrame, Series\n",
    "try:\n",
    "    from scipy.interpolate import interp2d  # type: ignore\n",
    "except ImportError:\n",
    "    interp2d = None\n",
    "#these two seem be fixed\n",
    "M: int = 12\n",
    "N: int = 16"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "l: int = N #length of zones (16)\n",
    "w: int = M # width of zones (12)\n",
    "# we are doing 12 x 16 <- this can change\n",
    "\n",
    "#This can be the exact same for our hockey functions\n",
    "def _get_cell_indexes(x: Series, y: Series, l: int = N, w: int = M) -> Tuple[Series, Series]:\n",
    "    xmin = 0\n",
    "    ymin = 0\n",
    "\n",
    "    xi = (x - xmin) / spadlconfig.field_length * l #spadlconfig.length is just the max x \n",
    "    yj = (y - ymin) / spadlconfig.field_width * w #spadlconfig.width is just the max y \n",
    "    xi = xi.astype(int).clip(0, l - 1)\n",
    "    yj = yj.astype(int).clip(0, w - 1)\n",
    "    return xi, yj\n",
    "\n",
    "xi, yj = _get_cell_indexes(actions.start_x, actions.start_y, l, w)\n",
    "#xi[:10]\n",
    "#yj[:10]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0    8\n",
      "1    4\n",
      "2    4\n",
      "3    3\n",
      "4    9\n",
      "Name: start_x, dtype: int32\n",
      "0    3\n",
      "1    4\n",
      "2    3\n",
      "3    5\n",
      "4    3\n",
      "Name: start_y, dtype: int32\n"
     ]
    }
   ],
   "source": [
    "# This is what the funciton escencially does. It transforms x and y start to fit our new \n",
    "# 16*12 field\n",
    "print(((actions.start_x - 0) / actions.start_x.max() * 16).astype(int).clip(0,16-1)[:5])\n",
    "print(((actions.start_y - 0) / actions.start_x.max() * 12).astype(int).clip(0,12-1)[:5])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0    8\n",
       "1    4\n",
       "2    4\n",
       "3    3\n",
       "4    9\n",
       "Name: start_x, dtype: int32"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "xi, yj = _get_cell_indexes(actions.start_x, actions.start_y, l, w)\n",
    "xi[:5]\n",
    "#yj[:5]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0    7\n",
       "1    4\n",
       "2    4\n",
       "3    2\n",
       "4    8\n",
       "Name: start_x, dtype: int32"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Values of xi and yj will change if we change values of l and w. \n",
    "# For example:\n",
    "xi, yj = _get_cell_indexes(actions.start_x, actions.start_y, l=14, w=10)\n",
    "xi.head(5)\n",
    "#yj.head(5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0    104\n",
       "1     84\n",
       "2    100\n",
       "3     51\n",
       "4    121\n",
       "dtype: int32"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# honestly I don't yet understand what is the purpose of this yet but i assume it will make \n",
    "# sense eventually. \n",
    "# All I know it is a funciton of length, width, transformed x, and transformed y ona  given point\n",
    "\n",
    "def _get_flat_indexes(x: Series, y: Series, l: int = N, w: int = M) -> Series:\n",
    "    xi, yj = _get_cell_indexes(x, y, l, w)\n",
    "    return l * (w - 1 - yj) + xi \n",
    "# yj and xi are the transformed x and y for every point \n",
    "# we get in get_cell_indexes\n",
    "\n",
    "_get_flat_indexes(x=actions.start_x, y=actions.start_y, l=16,w=12)[:5]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(192,)"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#one clue: there are 192 unique values which is = 16*12 (our field)\n",
    "_get_flat_indexes(x=actions.start_x, y=actions.start_y, l=16,w=12).unique().shape\n",
    "#So I guess it is giving an index values for every square. and assigning each value\n",
    "# to all points inside a given square"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(907,)"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "array_=_get_flat_indexes(x=actions.start_x, y=actions.start_y, l=16,w=12) \n",
    "array_[array_ == array_[0]].shape # for example, 907 points inside square: array_[0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[ 112.  239.  381.  452.  874.  887. 1087. 1331. 1439. 1359. 1282. 1545.\n",
      "  1081.  881.  402.  545.]\n",
      " [ 145.  181.  365.  415.  557.  648.  928.  879.  908.  848.  783.  865.\n",
      "   651.  649.  396.  236.]\n",
      " [ 123.  309.  478.  601.  759.  755.  886.  880.  870.  770.  660.  833.\n",
      "   629.  527.  342.  210.]\n",
      " [ 193.  309.  629.  710. 1058.  952. 1282. 1257. 1296. 1074.  750.  827.\n",
      "   608.  511.  287.  232.]\n",
      " [ 334.  424.  540.  515.  757.  774. 1096. 1069.  985.  855.  518.  533.\n",
      "   427.  356.  220.  125.]\n",
      " [1257.  667.  618.  524.  805.  838. 1032.  953.  886.  701.  527.  578.\n",
      "   375.  300.  257.  158.]\n",
      " [1224.  758.  650.  544.  819.  822. 1049.  979.  907.  677.  509.  592.\n",
      "   397.  259.  293.  132.]\n",
      " [ 324.  442.  540.  587.  764.  711. 1088. 1086.  944.  796.  508.  530.\n",
      "   450.  314.  208.  109.]\n",
      " [ 168.  315.  613.  691. 1011.  940. 1101. 1190. 1145.  948.  714.  901.\n",
      "   578.  486.  260.  179.]\n",
      " [ 130.  284.  464.  597.  741.  616.  848.  859.  778.  741.  696.  778.\n",
      "   597.  537.  347.  222.]\n",
      " [ 120.  186.  323.  443.  669.  654.  793.  893.  856.  891.  766.  744.\n",
      "   611.  691.  372.  223.]\n",
      " [ 115.  213.  364.  514.  863.  819. 1029. 1304. 1460. 1563. 1380. 1550.\n",
      "  1117.  961.  502.  499.]]\n"
     ]
    }
   ],
   "source": [
    "# This is pretty well commented adn explained. \n",
    "# So just read the comments and I'll print the example\n",
    "#this is where we use flat_indexes, btw\n",
    "def _count(x: Series, y: Series, l: int = N, w: int = M) -> np.ndarray:\n",
    "    \"\"\"Count the number of actions occurring in each cell of the grid.\n",
    "    Parameters\n",
    "    ----------\n",
    "    x : pd.Series\n",
    "        The x-coordinates of the actions.\n",
    "    y : pd.Series\n",
    "        The y-coordinates of the actions.\n",
    "    l : int\n",
    "        Amount of grid cells in the x-dimension of the grid.\n",
    "    w : int\n",
    "        Amount of grid cells in the y-dimension of the grid.\n",
    "\n",
    "    Returns\n",
    "    -------\n",
    "    np.ndarray\n",
    "        A matrix, denoting the amount of actions occurring in each cell. The\n",
    "        top-left corner is the origin.\n",
    "    \"\"\"\n",
    "    #first it gets rid of nan values\n",
    "    x = x[~np.isnan(x) & ~np.isnan(y)]\n",
    "    y = y[~np.isnan(x) & ~np.isnan(y)]\n",
    "    #here are the flat indexes smh\n",
    "    flat_indexes = _get_flat_indexes(x, y, l, w)\n",
    "    vc = flat_indexes.value_counts(sort=False) #counts number of points in each square\n",
    "                                               #store it in a vector\n",
    "    vector = np.zeros(w * l) #creating a matrix of 0's to transform our cv vector\n",
    "    vector[vc.index] = vc # there you go\n",
    "    return vector.reshape((w, l)) #wanna make sure to have the shape of our matrix same as\n",
    "                                  # our field of coure\n",
    "\n",
    "#Example using data\n",
    "print(_count(actions.start_x, actions.start_y, l=16, w= 12))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "#this function will divide the matrices at the end of the scoring probability function\n",
    "#Pretty straightforward stuff, he is using the scoring rate per square as probability\n",
    "def _safe_divide(a: np.ndarray, b: np.ndarray) -> np.ndarray:\n",
    "    return np.divide(a, b, out=np.zeros_like(a), where=b != 0)\n",
    "\n",
    "#This is where it gets (more) fun\n",
    "def scoring_prob(actions: DataFrame[SPADLSchema], l: int = N, w: int = M) -> np.ndarray:\n",
    "    \"\"\"Compute the probability of scoring when taking a shot for each cell.\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    actions : pd.DataFrame\n",
    "        Actions, in SPADL format.\n",
    "    l : int\n",
    "        Amount of grid cells in the x-dimension of the grid.\n",
    "    w : int\n",
    "        Amount of grid cells in the y-dimension of the grid.\n",
    "\n",
    "    Returns\n",
    "    -------\n",
    "    np.ndarray\n",
    "        A matrix, denoting the probability of scoring for each cell.\n",
    "    \"\"\"\n",
    "    #first filters for shots and goals \n",
    "    shot_actions = actions[(actions.type_name == 'shot')]\n",
    "    goals = shot_actions[(shot_actions.result_name == 'success')]\n",
    "    #uses the function we created before to count number of events per square\n",
    "    #so we have two matrices (representing our field)\n",
    "    #one is shots, the other is goals, we divide the two to get the goal rate/shoot per square\n",
    "    shotmatrix = _count(shot_actions.start_x, shot_actions.start_y, l, w)\n",
    "    goalmatrix = _count(goals.start_x, goals.start_y, l, w)\n",
    "    return _safe_divide(goalmatrix, shotmatrix)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "shape: (12, 16)\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "array([[0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "        0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "        0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "        0.        ],\n",
       "       [0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "        0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "        0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "        0.        ],\n",
       "       [0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "        0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "        0.        , 0.        , 0.        , 0.        , 0.25      ,\n",
       "        0.        ],\n",
       "       [0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "        0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "        0.        , 0.        , 0.05      , 0.06521739, 0.        ,\n",
       "        0.0625    ],\n",
       "       [0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "        0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "        0.        , 0.        , 0.02439024, 0.025     , 0.1097561 ,\n",
       "        0.09302326],\n",
       "       [0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "        0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "        0.        , 0.03703704, 0.04545455, 0.07246377, 0.14529915,\n",
       "        0.20833333],\n",
       "       [0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "        0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "        0.        , 0.        , 0.02083333, 0.03174603, 0.12307692,\n",
       "        0.33766234],\n",
       "       [0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "        0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "        0.        , 0.        , 0.        , 0.07352941, 0.04615385,\n",
       "        0.05128205],\n",
       "       [0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "        0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "        0.        , 0.        , 0.03846154, 0.0754717 , 0.02083333,\n",
       "        0.        ],\n",
       "       [0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "        0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "        0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "        0.        ],\n",
       "       [0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "        0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "        0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "        0.        ],\n",
       "       [0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "        0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "        0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "        0.        ]])"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#it will work as long as the columsn are named correctly:\n",
    "#start_x, start_y, type_name, and result_name\n",
    "#so far this is very easy to adapt to our hockey data\n",
    "print('shape:',scoring_prob(actions, l=16, w=12).shape)\n",
    "scoring_prob(actions, l=16, w=12)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# For some reason I lost a lot of work... so I'll just write what I remember \n",
    "# and move forward"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_move_actions(actions: DataFrame[SPADLSchema]) -> DataFrame[SPADLSchema]:\n",
    "    \"\"\"Get all ball-progressing actions.\n",
    "\n",
    "    These include passes, dribbles and crosses. Take-ons are ignored because\n",
    "    they typically coincide with dribbles and do not move the ball to\n",
    "    a different cell.\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    actions : pd.DataFrame\n",
    "        Actions, in SPADL format.\n",
    "\n",
    "    Returns\n",
    "    -------\n",
    "    pd.DataFrame\n",
    "        All ball-progressing actions in the input dataframe.\n",
    "    \"\"\"\n",
    "    # which actions move the ball in our hockey data?\n",
    "    return actions[\n",
    "        (actions.type_name == 'pass')\n",
    "        | (actions.type_name == 'dribble')\n",
    "        | (actions.type_name == 'cross')\n",
    "    ]\n",
    "# which move actions where successful?\n",
    "def get_successful_move_actions(actions: DataFrame[SPADLSchema]) -> DataFrame[SPADLSchema]:\n",
    "    \"\"\"Get all successful ball-progressing actions.\n",
    "\n",
    "    These include successful passes, dribbles and crosses.\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    actions : pd.DataFrame\n",
    "        Actions, in SPADL format.\n",
    "\n",
    "    Returns\n",
    "    -------\n",
    "    pd.DataFrame\n",
    "        All ball-progressing actions in the input dataframe.\n",
    "    \"\"\"\n",
    "    move_actions = get_move_actions(actions)\n",
    "    return move_actions[move_actions.result_name == 'success']\n",
    "\n",
    "\n",
    "\n",
    "#Num of move actions / total actions\n",
    "# num of shoots . total actions\n",
    "# to estimate prob of each\n",
    "def action_prob(\n",
    "    actions: DataFrame[SPADLSchema], l: int = N, w: int = M\n",
    ") -> Tuple[np.ndarray, np.ndarray]:\n",
    "    \"\"\"Compute the probability of taking an action in each cell of the grid.\n",
    "\n",
    "    The options are: shooting or moving.\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    actions : pd.DataFrame\n",
    "        Actions, in SPADL format.\n",
    "    l : pd.DataFrame\n",
    "        Amount of grid cells in the x-dimension of the grid.\n",
    "    w : pd.DataFrame\n",
    "        Amount of grid cells in the y-dimension of the grid.\n",
    "\n",
    "    Returns\n",
    "    -------\n",
    "    shotmatrix : np.ndarray\n",
    "        For each cell the probability of choosing to shoot.\n",
    "    movematrix : np.ndarray\n",
    "        For each cell the probability of choosing to move.\n",
    "    \"\"\"\n",
    "    move_actions = get_move_actions(actions)\n",
    "    shot_actions = actions[(actions.type_name == 'shot')]\n",
    "    \n",
    "    movematrix = _count(move_actions.start_x, move_actions.start_y, l, w)\n",
    "    shotmatrix = _count(shot_actions.start_x, shot_actions.start_y, l, w)\n",
    "    totalmatrix = movematrix + shotmatrix\n",
    "\n",
    "    return _safe_divide(shotmatrix, totalmatrix), _safe_divide(movematrix, totalmatrix)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
